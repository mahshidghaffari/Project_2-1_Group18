Index: app/src/main/java/controller/Game.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\n\nimport view.*;\n\nimport java.util.ArrayList;\nimport java.util.Random;\n\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\n\npublic class Game{\n\n    private ChessBoard cb;\n    public boolean newTurn=true;\n    private Dice dice;\n    private Player playing = null;\n    private WhitePlayer wPlayer;\n    private BaseLineAgent baseLinePlayer;\n    private ExpectiMaxAgent expectiMaxPlayer;\n    private BlackPlayer bPlayer;\n    private Piece heldPiece = null;\n    private ButtonPanel buttonPanel;\n    private boolean diceClicked=false;\n    private JFrame f;\n    private boolean noMoves = false;\n    private boolean noAgent = false;\n    private boolean baseLineActive = false;     // Make true to play with BaseLine Agent\n    private boolean expectiMaxActive = true;\n\n\n    /**\n     * Main Game Class, takes care of all buttons clicked by the listener and Gameplay situations\n     * @param f is the ChessBoard GUI Frame \n     */\n    \n    public Game(JFrame f){\n        this.f = f;\n        cb = new ChessBoard();\n        dice = new Dice();\n        bPlayer = new BlackPlayer(cb);\n        wPlayer = new WhitePlayer(cb);\n        buttonPanel= new ButtonPanel(this);\n    }\n    public JFrame getFrame(){\n        return f;\n    }\n    \n    public ChessBoard getChessBoard(){\n        return cb;\n    }\n    public void setNewChessBoard(){\n        this.cb = new ChessBoard();\n        \n    }\n    public boolean isNewTurn(){\n        return newTurn;\n    }\n    public Dice getDice(){\n        return dice;\n    }\n    public Player whosPlaying(){\n        return playing;\n    }\n    public void newTurn(){\n        newTurn=true;\n        diceClicked=false;\n        wPlayer.flipTurns(bPlayer);\n        updateBoard();\n    } \n    public void setButtonPanel(ButtonPanel buttonPanel){\n        this.buttonPanel = buttonPanel;\n    }\n    public void setDiceClicked(boolean b) {\n        diceClicked = b;\n    }\n    //public Castle getCastling(){ return castling;}\n    public WhitePlayer getWhitePlayer(){return wPlayer;}\n    public BlackPlayer getBlackPlayer(){return bPlayer;}\n\n    /**\n     * When Ever the Green Dice button is clicked by the user this method checks whether it is even a turn for the user\n     */\n    public void play(){\n        //noMoves = false;\n\n        if(wPlayer.getIsMyTurn()){        //if its w player's turn\n\n            playing = wPlayer;\n            newTurn= false;\n            String chosen = dice.getRoleDice(); //roll the dice\n            if(!wPlayer.canMove(chosen)){         //if player has no pieces to move we switch turns\n                //System.out.println(\"Sorry white , you have no possible moves. Turn goes to black\");\n                noMoves = true;\n                newTurn();\n            } else {\n                noMoves = false;\n            }\n        }\n\n        else if(bPlayer.getIsMyTurn()){\n\n        \t// Normal player (NO AGENT)\n        \tif (noAgent) {\n        \t\tplaying = bPlayer;\n        \t\tnewTurn= false;\n            \tString chosen = dice.getRoleDice();\n            \t//loop through all live pieces to see if dice chosen piece piece is there\n            \tfor(Piece p: cb.getLivePieces()){  \n            \t\tif(p.isWhite()){ continue; }   \n                \n            \t\tif(p.getPieceName().equals(chosen) ){ //if the chosen piece is not dead\n                        break;\n            \t\t}\n            \t}\n            \t\n            \tif(!bPlayer.canMove(chosen)){    \n            \t\t//System.out.println(\"Sorry black , you have no possible moves. Turn goes to white\");\n            \t\tnoMoves = true;\n            \t\tnewTurn();\n            \t} else {\n                    noMoves = false;\n                }\n        \t\n        \t// BASELINE AGENT\n        \t} else if (baseLineActive) {\n                baseLinePlayer = new BaseLineAgent(this, cb);\n            \tString chosen = dice.getRoleDice();\n            \tbaseLinePlayer.baseLinePlay(chosen);\n        \t\n        \t// EXPECTIMAX AGENT\n        \t} else if (expectiMaxActive) {\n                String chosen = dice.getRoleDice();\n                int depth = 1;\n                expectiMaxPlayer = new ExpectiMaxAgent(this, cb, chosen, depth, false);\n                expectiMaxPlayer.expectiMaxPlay();\n            }\n        }\n    }\n\n    /**\n     * This Method checks which button clicks are legal by the user and their correspondence to the ual \n     * In game play. \n     * @param clickedOnce a boolean that checks whether this click by the user is the first one or second\n     * @param clickedButton is the button that was clicked by the user\n     * @return true if the user is allowed to make these choices\n     */\n\n    public boolean isLegalChoice(boolean clickedOnce, SquareButton clickedButton){\n        Square clickedSquare = cb.getSquare(clickedButton); //get clicked square\n        Piece clickedPiece = clickedSquare.getPieceOnSq();\n        \n        if(wPlayer.getIsMyTurn()){ //if its the white turn\n            if(!diceClicked){ return false;}\n            if(!clickedOnce){ //and this click is the choice of which piece to move \n                if(!clickedSquare.isTakenSquare()){ return false; }    //if the sqaure is empty then do nothing\n                else if (clickedPiece.isWhite() && clickedPiece.getPieceName().equals(dice.getRoleDice()) ){ //if the player selected the correct piece to move\n                    heldPiece = clickedPiece;\n                    heldPiece.setHighlighted(true);\n                    highlightPiece(heldPiece, clickedSquare);\n                    System.out.println(\"legal first click\");\n                    buttonPanel.setText(\"legal first click\");\n\n                    return true;\n                }\n            }\n            else{ //if this is the second click\n                \n                if(heldPiece!=null && cb.getSquare(clickedButton).equals(heldPiece.getCurrentPosition())){   //if the player wants to move another piece\n                    heldPiece.setHighlighted(false);\n                    heldPiece=null;\n                    clickedOnce = false;\n                    System.out.println(\"released\");\n                    return true;\n                }\n                else if(heldPiece!=null && heldPiece.getLegalMoves(cb).contains(clickedSquare)){ //if the clicked square is in fact a legal one to move to\n                   \n                    int distance = Math.abs(clickedSquare.getXPos()-heldPiece.getCurrentPosition().getXPos());    //calculating the distance from the piece to desired moving location                \n                    \n                    if(heldPiece.getPieceName().equals(\"King\") && distance>1){                  //if the size of this movement is larger than 1 for the king it means this is castling\n                        ((King)heldPiece).doCastling(clickedSquare, cb, heldPiece);\n                        newTurn();\n                        return true;\n                    }\n                    if(heldPiece.getPieceName().equals(\"Pawn\") && clickedSquare.getYPos()==0){\n                        heldPiece.move(clickedSquare,cb, heldPiece.getLegalMoves(cb));\n                        Piece newPiece = clickedSquare.getPieceOnSq();\n                        ((Pawn)newPiece).promote(heldPiece.isWhite(),newPiece, clickedSquare, cb);\n                        newTurn();\n                        return true;\n                    }\n\n                    else{  //if its just a non castling move\n                        heldPiece.move(clickedSquare, cb, heldPiece.getLegalMoves(cb)); //move there    \n                        System.out.println(\"legal second click\");\n                        heldPiece.setHighlighted(false);\n                        heldPiece = null;\n                        newTurn();\n                        return true;\n                    }                    \n                }\n            }\n        }\n\n        else if(bPlayer.getIsMyTurn()){ //if its the black turn\n            if(!diceClicked){ return false;}\n            if(!clickedOnce){ //and this click is the choice of which piece to move \n                if(!clickedSquare.isTakenSquare()){ return false; }    //if the sqaure is empty then do nothing\n                else if (!clickedPiece.isWhite() && clickedPiece.getPieceName().equals(dice.getRoleDice()) ){ //if the player selected the correct piece to move\n                    heldPiece = clickedPiece;\n                    heldPiece.setHighlighted(true);\n                    highlightPiece(heldPiece, clickedSquare);\n                    System.out.println(\"legal first click\");\n                    return true;\n                }\n            }\n            else{ //if this is the second click\n                if(heldPiece!=null && cb.getSquare(clickedButton).equals(heldPiece.getCurrentPosition())){   //if the player wants to move another piece\n                    heldPiece.setHighlighted(false);\n                    heldPiece=null;\n                    clickedOnce = false;\n                    System.out.println(\"released\");\n                    updateBoard();\n                    return true;\n                }\n                else if(heldPiece!=null && heldPiece.getLegalMoves(cb).contains(clickedSquare)){ //if the clicked square is in fact a legal one to move to\n                    \n                    int distance = Math.abs(clickedSquare.getXPos()-heldPiece.getCurrentPosition().getXPos());    //calculating the distance from the piece to desired moving location                \n                    \n                    if(heldPiece.getPieceName().equals(\"King\") && distance>1){                  //if the size of this movement is larger than 1 for the king it means this is castling\n                        ((King)heldPiece).doCastling(clickedSquare,cb,heldPiece);\n                        newTurn();\n                        return true;\n                    }\n                    if(heldPiece.getPieceName().equals(\"Pawn\") && clickedSquare.getYPos()==7){\n                        heldPiece.move(clickedSquare,cb, heldPiece.getLegalMoves(cb));\n                        Piece newPiece = clickedSquare.getPieceOnSq();\n                        ((Pawn)newPiece).promote(heldPiece.isWhite(),newPiece, clickedSquare, cb);\n                        newTurn();\n                        return true;\n                    }\n\n                    else{  //if its just a non castling move\n                        heldPiece.move(clickedSquare, cb, heldPiece.getLegalMoves(cb)); //move there\n                        heldPiece.setHighlighted(false);\n                        heldPiece = null;    \n                        newTurn();\n                        System.out.println(\"legal second click\");\n                        return true;                    \n                    }\n                }\n            }    \n        }\n        return false;\n    }\n\n    /**\n     * This repaints the board after any movement or capture\n     */\n    public void updateBoard(){\n        Square[][] board = cb.getBoard();\n        wPlayer.updateScore();  //accounting for any captures\n        bPlayer.updateScore();\n        for(int i=0; i<8; i++){\n            for(int j=0;j<8;j++){\n                if(board[i][j].isTakenSquare()){\n                    Piece occupying = board[i][j].getPieceOnSq();\n                    board[i][j].getButtonOnSquare().setIcon(occupying.getImgIcon());\n                }\n                else{\n                    board[i][j].getButtonOnSquare().setIcon(new ImageIcon());\n                }\n            }\n        }\n    }\n\n    /**\n     * This method highlights a legal clicked piece\n     * @param piece is the piece in question needing highlighting\n     * @param square is the Square in question to highlight\n     */\n    public void highlightPiece(Piece piece, Square square) {\n        square.removeImage();\n\n        updateBoard();\n        square.placeImage(piece);\n    }\n\n    public boolean isNoMoves() { return noMoves; }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/controller/Game.java b/app/src/main/java/controller/Game.java
--- a/app/src/main/java/controller/Game.java	(revision 29dd225ffbc520c0828c2612ef0d37cfa99a8e45)
+++ b/app/src/main/java/controller/Game.java	(date 1636638346666)
@@ -130,7 +130,7 @@
         	// EXPECTIMAX AGENT
         	} else if (expectiMaxActive) {
                 String chosen = dice.getRoleDice();
-                int depth = 1;
+                int depth = 4;
                 expectiMaxPlayer = new ExpectiMaxAgent(this, cb, chosen, depth, false);
                 expectiMaxPlayer.expectiMaxPlay();
             }
Index: .idea/runConfigurations.xml
===================================================================
diff --git a/.idea/runConfigurations.xml b/.idea/runConfigurations.xml
deleted file mode 100644
--- a/.idea/runConfigurations.xml	(revision 29dd225ffbc520c0828c2612ef0d37cfa99a8e45)
+++ /dev/null	(revision 29dd225ffbc520c0828c2612ef0d37cfa99a8e45)
@@ -1,10 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="RunConfigurationProducerService">
-    <option name="ignoredProducers">
-      <set>
-        <option value="com.android.tools.idea.compose.preview.runconfiguration.ComposePreviewRunConfigurationProducer" />
-      </set>
-    </option>
-  </component>
-</project>
\ No newline at end of file
Index: .idea/compiler.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"CompilerConfiguration\">\n    <bytecodeTargetLevel target=\"14\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/compiler.xml b/.idea/compiler.xml
--- a/.idea/compiler.xml	(revision 29dd225ffbc520c0828c2612ef0d37cfa99a8e45)
+++ b/.idea/compiler.xml	(date 1636638346830)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="CompilerConfiguration">
-    <bytecodeTargetLevel target="14" />
+    <bytecodeTargetLevel target="11" />
   </component>
 </project>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ExternalStorageConfigurationManager\" enabled=\"true\" />\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_14\" default=\"true\" project-jdk-name=\"openjdk-16\" project-jdk-type=\"JavaSDK\" />\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision 29dd225ffbc520c0828c2612ef0d37cfa99a8e45)
+++ b/.idea/misc.xml	(date 1636638387686)
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="ExternalStorageConfigurationManager" enabled="true" />
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_14" default="true" project-jdk-name="openjdk-16" project-jdk-type="JavaSDK" />
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_11" default="true" project-jdk-name="openjdk-16" project-jdk-type="JavaSDK" />
 </project>
\ No newline at end of file
